// SPDX-FileCopyrightText: 2021 Carson Black <uhhadd@gmail.com>
//
// SPDX-License-Identifier: MPL-2.0

package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
)

func GenerateGoClient(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_hrpc_client.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-go-hrpc. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	genClientContent(g, file)
}

func genClientContent(g *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		genClientService(g, service)
	}
}

func genClientService(g *protogen.GeneratedFile, service *protogen.Service) {
	serverType := service.GoName + "Client"
	g.P("type ", serverType, " interface {")
	for _, method := range service.Methods {
		g.P(method.Comments.Leading, serverSignature(g, method, false))
	}
	g.P("}")
	g.P()
	genClientHTTPImpl(g, service)
	genClientTestHTTPImpl(g, service)
}

func genClientHTTPImpl(g *protogen.GeneratedFile, service *protogen.Service) {
	dummyType := "HTTP" + service.GoName + "Client"
	g.P("type ", dummyType, " struct {")
	g.P("Client ", g.QualifiedGoIdent(httpPackage.Ident("Client")))
	g.P("BaseURL string")
	g.P("WebsocketProto string")
	g.P("WebsocketHost string")
	g.P("Header ", httpPackage.Ident("Header"))
	g.P("}")
	for _, method := range service.Methods {
		g.P("func (", "client *", dummyType, ") ", clientSignature(g, method), " {")
		if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			genClientBidiStreaming(g, service, method)
		} else if method.Desc.IsStreamingServer() {
			g.P("return nil, ", g.QualifiedGoIdent(errorPackage.Ident("New")), `("unimplemented")`)
		} else if method.Desc.IsStreamingClient() {
			g.P("return nil, ", g.QualifiedGoIdent(errorPackage.Ident("New")), `("unimplemented")`)
		} else {
			genClientUnary(g, service, method)
		}

		g.P("}")
	}
}

func genClientTestHTTPImpl(g *protogen.GeneratedFile, service *protogen.Service) {
	dummyType := "HTTPTest" + service.GoName + "Client"
	g.P("type ", dummyType, " struct {")
	g.P("Client ", "interface { Test(", "*", g.QualifiedGoIdent(httpPackage.Ident("Request")), ", ...int", ")", "(*", httpPackage.Ident("Response"), ", error) }")
	g.P("}")
	for _, method := range service.Methods {
		g.P("func (", "client *", dummyType, ") ", clientSignature(g, method), " {")
		if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			g.P("return nil, ", g.QualifiedGoIdent(errorPackage.Ident("New")), `("unimplemented")`)
		} else if method.Desc.IsStreamingServer() {
			g.P("return nil, ", g.QualifiedGoIdent(errorPackage.Ident("New")), `("unimplemented")`)
		} else if method.Desc.IsStreamingClient() {
			g.P("return nil, ", g.QualifiedGoIdent(errorPackage.Ident("New")), `("unimplemented")`)
		} else {
			genClientTestUnary(g, service, method)
		}

		g.P("}")
	}
}

func genClientMarshal(fromVar, toVar, err string, g *protogen.GeneratedFile, service *protogen.Service) {
	marshal := g.QualifiedGoIdent(protoPackage.Ident("Marshal"))

	g.P(toVar, ", ", err, " := ", marshal, "(", fromVar, ")")
	g.P("if ", err, "!=", "nil", "{")
	g.P("return nil, ", err)
	g.P("}")
}

func genClientBidiStreaming(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	g.P(`u := `,
		g.QualifiedGoIdent(urlPackage.Ident("URL")), `{`,
		`Scheme: client.WebsocketProto,`,
		`Host: client.WebsocketHost,`,
		`Path: `, fmt.Sprintf(`"/%s/%s"`, method.Desc.FullName().Parent(), method.Desc.Name()), `,`,
		`}`)

	g.P(`inC := req`)
	g.P(`outC := make(chan *`, g.QualifiedGoIdent(method.Output.GoIdent), `)`)

	g.P(`c, _, err := `, g.QualifiedGoIdent(websocketPackage.Ident("DefaultDialer")), `.Dial(u.String(), client.Header)`)
	g.P(`if err != nil {`)
	g.P(`return nil, err`)
	g.P(`}`)

	g.P(`go func() {`)
	{
		g.P(`defer c.Close()`)

		g.P(`msgs := make(chan []byte)`)

		g.P(`go func() {`)
		{
			g.P(`for {`)
			{
				g.P(`_, message, err := c.ReadMessage()`)
				g.P(`if err != nil {`)
				g.P(`close(msgs)`)
				g.P(`break`)
				g.P(`}`)
				g.P(`msgs <- message`)
			}
			g.P(`}`)
		}
		g.P(`}()`)

		g.P(`for {`)
		g.P(`select {`)
		{
			g.P(`case msg, ok := <-msgs:`)
			g.P(`if !ok {
				close(inC)
				close(outC)
				return
			}`)

			g.P(`thing := &`, g.QualifiedGoIdent(method.Output.GoIdent), `{}`)
			g.P(`err := `, g.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), `(msg[1:], thing)`)
			g.P(`if err != nil {
				close(inC)
				close(outC)
				return
				}`)

			g.P(`outC <- thing`)
		}
		{
			g.P(`case send, ok := <-inC:`)
			g.P(`if !ok {
				close(outC)
				return
				}`)

			g.P(`data, err := proto.Marshal(send)`)
			g.P(`if err != nil {
				return
				}`)

			g.P(`err = c.WriteMessage(`, g.QualifiedGoIdent(websocketPackage.Ident("BinaryMessage")), `, data)`)
			g.P(`if err != nil {
				return
				}`)
		}
		g.P(`}`)
		g.P(`}`)
	}
	g.P(`}()`)

	g.P(`return outC, nil`)
}

func genClientUnmarshal(fromVar, toVar, err string, kind protogen.GoIdent, g *protogen.GeneratedFile, service *protogen.Service) {
	unmarshal := g.QualifiedGoIdent(protoPackage.Ident("Unmarshal"))

	g.P(toVar, " := ", "&", g.QualifiedGoIdent(kind), "{}")
	g.P(err, " := ", unmarshal, "(", fromVar, ",", toVar, ")")
	g.P("if ", err, "!=", "nil", "{")
	g.P("return nil, ", err)
	g.P("}")
}

func genClientUnary(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	genClientMarshal("req", "data", "marshalErr", g, service)
	g.P("reader := ", g.QualifiedGoIdent(bytesPackage.Ident("NewReader")), "(data)")
	g.P(`hreq, err := http.NewRequest("POST", client.BaseURL + `, fmt.Sprintf(`"/%s/%s"`, method.Desc.FullName().Parent(), method.Desc.Name()), `, reader)`)
	g.P(`if err != nil {`)
	g.P(`return nil, err`)
	g.P(`}`)
	g.P(`for k, v := range client.Header {`)
	g.P(`hreq.Header[k] = v`)
	g.P(`}`)
	g.P(`hreq.Header.Add("content-type", "application/hrpc")`)
	g.P(`resp, err := client.Client.Do(hreq)`)
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	g.P("body, err := ", g.QualifiedGoIdent(ioutilPackage.Ident("ReadAll")), "(resp.Body)")
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	genClientUnmarshal("body", "ret", "unmarshalErr", method.Output.GoIdent, g, service)
	g.P("return ret, nil")
}

func genClientTestUnary(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	genClientMarshal("req", "data", "marshalErr", g, service)
	g.P("reader := ", g.QualifiedGoIdent(bytesPackage.Ident("NewReader")), "(data)")
	g.P("testreq := ", g.QualifiedGoIdent(httptestPackage.Ident("NewRequest")), `("POST", `, fmt.Sprintf(`"/%s/%s"`, method.Desc.FullName().Parent(), method.Desc.Name()), `, reader)`)
	g.P("resp, err := client.Client.Test(testreq)")
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	g.P("body, err := ", g.QualifiedGoIdent(ioutilPackage.Ident("ReadAll")), "(resp.Body)")
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	genClientUnmarshal("body", "ret", "unmarshalErr", method.Output.GoIdent, g, service)
	g.P("return ret, nil")
}

func clientSignature(g *protogen.GeneratedFile, m *protogen.Method) string {
	var inputArg string
	var ret string
	inputType := g.QualifiedGoIdent(m.Input.GoIdent)
	outputType := g.QualifiedGoIdent(m.Output.GoIdent)
	if m.Desc.IsStreamingClient() {
		inputArg = "chan *" + inputType
	} else {
		inputArg = "*" + inputType
	}
	if m.Desc.IsStreamingServer() {
		ret = "chan *" + outputType
	} else {
		ret = "*" + outputType
	}
	return fmt.Sprintf("%s(req %s) (%s, error)", m.GoName, inputArg, ret)
}
