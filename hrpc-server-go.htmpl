{{ $base := (trimSuffix (filepathBase .Name) ".proto") }}
{{ setFilename (sprintf "%s/%s.hrpc.server.go" (deref .Options.GoPackage) $base) }}

{{ $item := . }}

package {{ filepathBase .Options.GoPackage }}

import "context"
import "net/http"

{{ $imports := newset }}

{{ range .Service }}

    {{ range .Method }}

        {{ if (not (or (hasClientStream .) (hasServerStream .)) ) }}
            {{ $resIn := (resolvedGoType $item . .InputType ) }}
            {{ $resOut := (resolvedGoType $item . .OutputType ) }}

            {{ appendSet $imports $resIn.Package }}
            {{ appendSet $imports $resOut.Package }}
        {{ end }}

    {{ end }}

{{ end }}

{{ range $k, $v := $imports }}

    import "{{ $k }}"

{{ end }}

{{ if .Service }}
{{ setOK true }}
{{ end }}

{{ range .Service }}

    {{ $serv := . }}
    {{ $sname := (sprintf "%sServer" (deref .Name)) }}

    type {{ $sname }} interface {
    {{ range .Method }}

        {{ if (not (or (hasClientStream .) (hasServerStream .)) ) }}
            {{ $resIn := (resolvedGoType $item . .InputType ) }}
            {{ $resOut := (resolvedGoType $item . .OutputType ) }}

            {{ deref .Name }}(ctx context.Context, r *{{ $resIn.ID}}) (resp {{ $resOut.ID}}, err error)
        {{ end }}

    {{ end }}
    }

    type {{ deref .Name }}Handler struct {
        Server {{ $sname }}
    }

    func (h *{{ deref .Name }}Handler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
        switch (req.URL.Path) {
        {{ range .Method }}
        case "/{{ $item.Package }}.{{ $serv.Name }}/{{ .Name }}": {
            panic("unimplemented")
        }
        {{ end }}
        }
    }

{{ end }}

